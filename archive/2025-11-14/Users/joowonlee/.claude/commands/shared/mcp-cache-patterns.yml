# MCP Cache Patterns - Session-Level Caching for MCP Server Results
# Performance optimization through intelligent caching and parallel execution

## Legend
@include universal-constants.yml#Universal_Legend

## MCP Session Cache Architecture

```yaml
Cache_Storage:
  Base_Directory: ".claude/.cache/"
  Structure:
    Context7: ".claude/.cache/context7/"
    Sequential: ".claude/.cache/sequential/"
    Magic: ".claude/.cache/magic/"
    Puppeteer: ".claude/.cache/puppeteer/"
  
  Session_Management:
    Session_ID: "Generated at session start"
    Session_File: ".claude/.cache/session-{id}.json"
    Cleanup: "Remove expired caches on session end"
    
  Memory_Cache:
    In_Memory: "Fast access during active session"
    Disk_Backup: "Persist for session recovery"
    Size_Limit: "100MB per session"
```

## Context7 Cache Implementation

```yaml
Context7_Cache:
  TTL: 3600  # 1 hour
  Key_Format: "{library_name}_{version}_{topic}"
  
  Cache_Structure:
    key: "react_18.2.0_hooks"
    value:
      documentation: "Full documentation content"
      examples: "Code examples"
      timestamp: "Cache creation time"
      hit_count: "Number of cache hits"
      
  Cache_Operations:
    Before_Lookup:
      - Check_Memory_Cache: "Fastest access"
      - Check_Disk_Cache: "If not in memory"
      - Validate_TTL: "Ensure not expired"
      
    After_Lookup:
      - Store_Memory: "Keep in session memory"
      - Store_Disk: "Persist to .cache/context7/"
      - Update_Metadata: "Hit count, last access"
      
  Invalidation:
    TTL_Expired: "Remove from cache"
    Version_Change: "Clear old version cache"
    Manual_Clear: "--no-cache flag"
```

## Sequential Cache Implementation

```yaml
Sequential_Cache:
  TTL: "Session duration"  # Persist entire session
  Key_Format: "{problem_hash}_{thinking_depth}_{context_hash}"
  
  Problem_Hashing:
    Include: ["Core problem statement", "Key constraints", "Context type"]
    Exclude: ["Exact wording", "User formatting", "Timestamps"]
    Algorithm: "SHA256 of normalized problem"
    
  Cache_Structure:
    key: "a7f3b2c1_ultrathink_ctx9d8e7"
    value:
      analysis: "Full sequential analysis"
      steps: "Thinking steps taken"
      conclusions: "Key findings"
      recommendations: "Action items"
      timestamp: "Analysis time"
      reusable: "Can be adapted to similar problems"
      
  Reuse_Patterns:
    Exact_Match: "100% problem similarity"
    Partial_Match: "Core problem same, details differ"
    Pattern_Match: "Similar problem type"
    
  Storage:
    Location: ".claude/.cache/sequential/"
    Compression: "Gzip for large analyses"
    Index: "Problem type categorization"
```

## Magic Cache Implementation

```yaml
Magic_Cache:
  TTL: 7200  # 2 hours
  Key_Format: "{component_type}_{props_hash}_{framework}"
  
  Component_Hashing:
    Include: ["Component type", "Core props", "Framework"]
    Exclude: ["Styling details", "Minor props", "Names"]
    
  Cache_Structure:
    key: "button_a3f2b1c_react"
    value:
      component_code: "Full component implementation"
      dependencies: "Required imports"
      usage_example: "How to use component"
      variations: "Different prop combinations"
      timestamp: "Generation time"
      quality_score: "Component quality metric"
      
  Variation_Handling:
    Base_Component: "Core implementation cached"
    Prop_Variations: "Cache common variations"
    Style_Variations: "Apply on top of base"
    
  Storage:
    Location: ".claude/.cache/magic/"
    Organization: "By component type"
    Cleanup: "Remove least-used components"
```

## Parallel Execution Patterns

```yaml
Parallel_MCP_Execution:
  Detection:
    Multiple_Servers_Needed: "When command uses multiple MCP flags"
    Independent_Operations: "When MCP calls don't depend on each other"
    
  Execution_Patterns:
    Independent_Parallel:
      Example: "/analyze --c7 --seq"
      Pattern: |
        Promise.all([
          Context7.lookup(library),
          Sequential.analyze(problem)
        ])
      Benefits: "Faster execution, reduced wait time"
      
    Dependent_Sequential:
      Example: "C7 lookup â†’ Sequential analysis of results"
      Pattern: |
        const docs = await Context7.lookup(library);
        const analysis = await Sequential.analyze(docs);
      Requirements: "Order matters, can't parallelize"
      
    Batch_Operations:
      Example: "Multiple library lookups"
      Pattern: |
        Promise.all(
          libraries.map(lib => Context7.lookup(lib))
        )
      Optimization: "Single round-trip, batch processing"
      
  Error_Handling:
    Partial_Success: "Use successful results, note failures"
    Fallback_Sequential: "If parallel fails, try sequential"
    Timeout_Management: "Individual timeouts per operation"
```

## Cache Performance Optimization

```yaml
Performance_Strategies:
  Memory_Management:
    LRU_Eviction: "Least recently used removal"
    Size_Limits: "Per-cache type limits"
    Compression: "Gzip large entries"
    
  Access_Optimization:
    Memory_First: "Check memory before disk"
    Batch_Reads: "Load related entries together"
    Prefetch: "Anticipate next likely request"
    
  Hit_Rate_Improvement:
    Key_Normalization: "Consistent key generation"
    Fuzzy_Matching: "Find similar cached results"
    Pattern_Recognition: "Identify cacheable patterns"
    
  Monitoring:
    Hit_Rate: "Track cache effectiveness"
    Miss_Patterns: "Identify uncached patterns"
    Performance_Gains: "Measure time saved"
```

## Integration with Commands

```yaml
Command_Integration:
  Cache_Aware_Commands:
    analyze: "Check Sequential cache for similar analyses"
    build: "Check Magic cache for components"
    explain: "Check Context7 cache for documentation"
    test: "Cache test results and configurations"
    
  Cache_Control_Flags:
    --cache: "Force cache usage (default)"
    --no-cache: "Bypass cache completely"
    --refresh-cache: "Update cache with fresh data"
    --cache-only: "Only use cached data, no MCP calls"
    
  Cache_Reporting:
    Show_Hit_Rate: "Display cache effectiveness"
    List_Cached: "Show available cached data"
    Cache_Stats: "Performance improvements"
```

## Session Recovery & Persistence

```yaml
Session_Recovery:
  Checkpoint_Creation:
    Trigger: "Before major operations"
    Content: "Current cache state + session data"
    Location: ".claude/.cache/checkpoints/"
    
  Recovery_Process:
    Detect_Session: "Find most recent session"
    Load_Cache: "Restore memory cache from disk"
    Validate: "Check TTL and integrity"
    Resume: "Continue with cached context"
    
  Cross_Session_Learning:
    Pattern_Storage: "Save successful patterns"
    Problem_Templates: "Reusable analysis templates"
    Component_Library: "Built components catalog"
```

## Implementation Checklist

```yaml
Phase_2_Implementation:
  Core_Infrastructure:
    - [ ] Create cache directory structure
    - [ ] Implement cache key generation
    - [ ] Add TTL management
    - [ ] Create memory/disk cache layer
    
  MCP_Integration:
    - [ ] Modify Context7 calls to check cache
    - [ ] Add Sequential result caching
    - [ ] Implement Magic component cache
    - [ ] Add Puppeteer result caching
    
  Parallel_Execution:
    - [ ] Detect parallel opportunities
    - [ ] Implement Promise.all patterns
    - [ ] Add timeout management
    - [ ] Handle partial failures
    
  Performance_Monitoring:
    - [ ] Track cache hit rates
    - [ ] Measure performance gains
    - [ ] Report optimization opportunities
    - [ ] Generate performance reports
```

## MCP Fallback Chain System

```yaml
MCP_Fallback_Chains:
  Context7_Fallback:
    Primary: "Context7 resolve-library-id â†’ get-library-docs"
    Fallback_1: "WebSearch '[library] official documentation v{version}'"
    Fallback_2: "Grep project for existing usage patterns"
    Fallback_3: "WebSearch '[library] github examples'"
    Fallback_4: "Manual guidance: 'Unable to find docs, suggest alternatives'"

    Trigger_Conditions:
      Library_Not_Found: "Context7 returns no matches"
      Timeout: "Context7 takes >30s"
      Network_Error: "Connection failure to Context7"
      API_Error: "Context7 returns error response"

    Execution_Logic:
      1: "Try Context7 with 30s timeout"
      2: "On failure, immediately try WebSearch"
      3: "On WebSearch failure, search local project"
      4: "Log all attempts with confidence scores"
      5: "Return best available result with source attribution"

    Confidence_Scoring:
      Context7_Success: "95-100% confidence"
      WebSearch_Official: "85-95% confidence"
      Local_Pattern: "70-85% confidence"
      GitHub_Example: "60-75% confidence"
      No_Source: "0% - BLOCK implementation"

  Sequential_Fallback:
    Primary: "Sequential thinking server"
    Fallback_1: "Native step-by-step analysis with explicit reasoning"
    Fallback_2: "Structured problem decomposition"
    Fallback_3: "Simple linear analysis"

    Trigger_Conditions:
      Server_Unavailable: "Sequential server not responding"
      Timeout: "Analysis takes >5min"
      Resource_Exhaustion: "Too complex for Sequential"

    Execution_Logic:
      1: "Try Sequential with problem statement"
      2: "On timeout, switch to native structured analysis"
      3: "Break problem into smaller chunks"
      4: "Provide step-by-step native reasoning"
      5: "Log fallback method used"

    Quality_Comparison:
      Sequential_Server: "Highest quality, adaptive reasoning"
      Native_Structured: "Good quality, explicit steps"
      Simple_Linear: "Basic quality, straightforward analysis"

  Magic_Fallback:
    Primary: "Magic component builder from 21st.dev"
    Fallback_1: "Search existing project components"
    Fallback_2: "WebSearch '[framework] [component] accessibility pattern'"
    Fallback_3: "Generate from first principles with accessibility"
    Fallback_4: "Provide component template with TODOs"

    Trigger_Conditions:
      Component_Not_Found: "Magic returns no matches"
      Service_Unavailable: "21st.dev down or rate limited"
      Poor_Match: "Magic result quality <70%"
      Framework_Unsupported: "Framework not in Magic catalog"

    Execution_Logic:
      1: "Try Magic with component requirements"
      2: "Check local project for similar components"
      3: "WebSearch for accessible patterns"
      4: "Generate basic component structure"
      5: "Mark areas needing manual review"

    Component_Quality_Gates:
      Accessibility: "WCAG 2.1 AA compliance"
      Responsive: "Mobile-first design"
      TypeScript: "Full type safety"
      Testing: "Unit test included"
      Documentation: "Usage examples provided"

  Puppeteer_Fallback:
    Primary: "Puppeteer browser automation"
    Fallback_1: "Manual test guidance with step-by-step instructions"
    Fallback_2: "Playwright script template"
    Fallback_3: "Cypress test template"
    Fallback_4: "Manual QA checklist"

    Trigger_Conditions:
      Browser_Unavailable: "Chrome not running or accessible"
      Connection_Failed: "Cannot connect to debugging port"
      Page_Load_Timeout: "Page takes >30s to load"
      Automation_Blocked: "Site blocks automation"

    Execution_Logic:
      1: "Try Puppeteer with target URL"
      2: "On failure, generate manual test instructions"
      3: "Provide alternative automation tool scripts"
      4: "Include manual QA validation steps"

Global_Fallback_Strategy:
  Error_Detection:
    Timeout: "Operation exceeds reasonable duration"
    Network_Error: "Connection/DNS failures"
    API_Error: "Server returns error response"
    Rate_Limit: "Too many requests"
    Resource_Exhaustion: "Out of memory/quota"
    Invalid_Response: "Malformed or unexpected response"

  Recovery_Actions:
    Log_Failure:
      Level: "WARNING"
      Details: "Server name, error type, attempted operation"
      Timestamp: "ISO 8601 format"
      Context: "User request + environment state"

    Notify_User:
      Format: "âš  {MCP_SERVER} unavailable, using fallback: {METHOD}"
      Transparency: "Explain quality impact"
      Confidence: "Show confidence score of fallback"

    Update_Cache:
      Mark_Failed: "Track server failures for circuit breaker"
      Failure_Count: "Increment failure counter"
      Cooldown: "Avoid retrying failed server for 5min"

    Circuit_Breaker:
      Threshold: "3 consecutive failures"
      Cooldown_Period: "5 minutes"
      Gradual_Recovery: "Test with single request after cooldown"
      Full_Recovery: "Re-enable after 2 successful requests"

Fallback_Quality_Assurance:
  Confidence_Thresholds:
    Implementation_Required: ">= 90%"
    Warning_Level: "80-89%"
    Review_Required: "70-79%"
    Block_Implementation: "< 70%"

  Source_Attribution:
    Primary_Success: "Source: {MCP_SERVER} via {METHOD}"
    Fallback_Used: "Source: {FALLBACK_METHOD} (Primary unavailable)"
    Multiple_Sources: "Sources: {SOURCE_1}, {SOURCE_2} (cross-verified)"
    Provisional: "PROVISIONAL: {SOURCE} (confidence {SCORE}%)"

  User_Transparency:
    Always_Show:
      - Which MCP server was attempted
      - Why fallback was triggered
      - What fallback method was used
      - Confidence score of result
      - Any limitations of fallback approach

  Performance_Tracking:
    Metrics:
      Fallback_Frequency: "Track how often fallbacks occur"
      Fallback_Type: "Which servers fail most"
      Recovery_Time: "How long until server recovers"
      Quality_Impact: "Confidence score degradation"

    Reports:
      Location: ".claudedocs/mcp-health/fallback-report-{YYYY-MM-DD}.md"
      Contents:
        - Fallback statistics by server
        - Most common failure reasons
        - Average confidence scores
        - Recommendations for improvement
```

## Intelligent Retry Logic

```yaml
Retry_Strategies:
  Exponential_Backoff:
    Initial_Delay: "1 second"
    Max_Delay: "30 seconds"
    Multiplier: "2x per attempt"
    Max_Attempts: "3"
    Jitter: "Â±20% randomization"

  Conditional_Retry:
    Retry_On:
      - Network timeouts
      - Rate limiting (after cooldown)
      - Temporary server errors (5xx)
      - Transient connection failures

    Do_Not_Retry:
      - Invalid requests (4xx)
      - Authentication failures
      - Resource not found
      - Malformed responses
      - Quota exceeded

  Smart_Retry_Decision:
    Quick_Fail: "For user-facing commands, fail fast (1 retry max)"
    Background_Tasks: "For async operations, retry more (3 retries)"
    Critical_Operations: "For deployments, retry with confirmation"

Degraded_Mode_Operation:
  MCP_Unavailable:
    Status: "DEGRADED MODE ACTIVE"
    Notification: "ðŸ”„ Operating in degraded mode: MCP servers unavailable"
    Capabilities:
      - "Native tool functionality: FULL"
      - "External research: LIMITED"
      - "Component generation: MANUAL"
      - "Complex analysis: BASIC"

    User_Guidance:
      - "What still works: File ops, git, testing, building"
      - "What's limited: Library research, UI generation, deep analysis"
      - "Recommendations: Defer complex research until servers recover"

  Partial_Availability:
    Status: "PARTIAL MCP FUNCTIONALITY"
    Notification: "âš  Some MCP servers unavailable: {AVAILABLE_SERVERS} working"
    Strategy: "Route requests to available servers only"

  Recovery_Detection:
    Health_Check: "Periodic ping to failed servers"
    Frequency: "Every 5 minutes"
    Success_Threshold: "2 consecutive successful health checks"
    Notification: "âœ… {SERVER} recovered and re-enabled"
```

---
*MCP Cache Patterns v3 - Session-level caching, parallel execution, and comprehensive fallback chains*